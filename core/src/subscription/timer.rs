use crate::L4Pdu;
use std::time::{Duration, Instant};

// TODO document, make useful as a utility?

pub trait CallbackTimer {
    fn new(count: u64) -> Self;
    fn update(&mut self, pdu: &L4Pdu) -> bool;
}

pub struct Milliseconds {
    last_invoked: Instant,
    interval: Duration,
}

impl CallbackTimer for Milliseconds {
    fn new(count: u64) -> Self {
        Self {
            last_invoked: Instant::now(),
            interval: Duration::from_millis(count),
        }
    }

    fn update(&mut self, _pdu: &L4Pdu) -> bool {
        if Instant::now() - self.last_invoked >= self.interval {
            self.last_invoked = Instant::now();
            return true;
        }
        false
    }
}

pub struct Packets {
    count_remaining: u64,
    count: u64,
}

impl CallbackTimer for Packets {
    fn new(count: u64) -> Self {
        Self {
            count_remaining: count,
            count,
        }
    }

    fn update(&mut self, _pdu: &L4Pdu) -> bool {
        self.count_remaining -= 1;
        if self.count_remaining == 0 {
            self.count_remaining = self.count;
            return true;
        }
        false
    }
}

// Bytes, excluding Ethernet, IP, and TCP headers.
pub struct Bytes {
    count_remaining: u64,
    count: u64,
}

impl CallbackTimer for Bytes {
    fn new(count: u64) -> Self {
        Self {
            count_remaining: count,
            count,
        }
    }

    fn update(&mut self, pdu: &L4Pdu) -> bool {
        let len = pdu.length() as u64;
        if len >= self.count_remaining {
            let over = len - self.count_remaining;
            self.count_remaining = if over >= self.count {
                0
            } else {
                self.count - over
            };
            return true;
        }
        self.count_remaining -= len;
        false
    }
}

/*

Rough pseudocode for how this might be used


#[doc(hidden)]
/// Private structure generated by the compiler for each StreamingCallback.
pub struct TimedCallbackWrapper<T, R>
where
    T: Tracked,
    R: CallbackTimer,
{
    /// Starts as `Some`; changed to `None` if:
    /// - Filter itself fails to match, or
    /// - Term + nonterm == 0
    /// When this is None, the filter is no longer active and thus
    /// no longer invoked.
    pub callback: Option<C>,
    /// Owned tracked data. This is initialized at the start of the connection
    /// and accumulated until the callback is ready to be invoked.
    /// After that, it is delivered when the callback timer fires.
    /// After each delivery, it is cleared such that, at the next invocation,
    /// only new data is delivered.
    tracked: Option<T>,
    /// Streaming callback timer. Once active, the timer is updated on every
    timer: Option<R>,
}

impl<T, R> TimedCallbackWrapper<T, R>
where
    T: Tracked,
    R: CallbackTimer,
{
    /// Create a new callback wrapper.
    pub fn new(first_packet: &L4Pdu) -> Self {
        TimedCallbackWrapper {
            callback: None,
            tracked: Some(T::new(first_packet)),
            timer: None,
        }
    }

    /// Returns true if the filter should be invoked.
    pub fn is_active(&self) -> bool {
        self.callback.is_some()
    }

    /// Invoked when a filter pattern for callback has matched.
    pub fn set_active(&mut self, counter: u64) {
        self.callback = Some(C::new());
        self.timer = Some(R::new(counter));
    }

    /// Invoked when the callback has unsubscribed.
    pub fn set_inactive(&mut self) {
        self.callback = None;
    }

    /// Invoked on each PDU. Updates the tracked datatype and, if the callback is active,
    /// invokes the timer. If the timer indicates, the callback will execute.
    pub fn update(&mut self, pdu: &L4Pdu) {
        if let Some(tracked) = &mut self.tracked {
            tracked.update(pdu);
            if let Some(timer) = &mut self.timer {
                if timer.update(pdu) {
                    let tracked = self.tracked.as_mut().unwrap();
                    self.callback.as_mut().unwrap().invoke(tracked, pdu);
                    tracked.clear();
                }
            }
        }
    }
}

*/

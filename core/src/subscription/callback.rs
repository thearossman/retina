use super::Tracked;
use crate::conntrack::StateTransition;
use crate::L4Pdu;

/// This streaming callback trait should be used when a user can
/// accept read-only access to tracked data. If no internal state is
/// needed, the user can implement this trait on an empty struct.
/// If the user needs mutable tracked data, they should store it internally,
/// request updates on each packet, and maintain their own timer for any
/// separate processing.
pub trait StreamingCallback<T>
where T: Tracked
{
    /// Initializes internal data, if applicable.
    /// Called on first packet in connection.
    fn new() -> Self;
    /// Invoked at specified intervals with tracked data
    /// (if a filter pattern matched). Phases of interest must
    /// be specified as attributes, e.g.: #[invoke(L4Payload)]
    /// Interval must be specified as attribute, e.g. #[streaming(packets=1)]
    /// If the interval is `packets=1`, then the PDU will also be delivered.
    /// If only PDUs are requested, use TrackedEmpty.
    /// If PDUs are requested, packets will be buffered until ready to be delivered.
    fn invoke(&mut self, data: &T, pdu: Option<&L4Pdu>) -> bool;
    /// Invoked for specified phase transitions.
    /// Phase transitions of interest must be specified as attributes.
    fn phase_tx(&mut self, state: StateTransition);
}

#[doc(hidden)]
/// Private structure generated by the compiler for each StreamingCallback.
/// See StreamingFilter for more details.
pub struct CallbackWrapper<T, C>
where
    T: Tracked,
    C: StreamingCallback<T>,
{
    /// Starts as `Some`; changed to `None` if:
    /// - Filter itself fails to match, or
    /// - Term + nonterm == 0
    /// When this is None, the filter is no longer active and thus
    /// no longer invoked.
    pub callback: Option<C>,
    /// Required to make the compiler happy so that we can specify `T`.
    tracked: std::marker::PhantomData<T>,
    /// Filter pattern preconditions have matched terminally
    /// None if there are no preconditions
    pub term: Option<u32>,
    /// Filter pattern preconditions that have matched non-terminally
    pub nonterm: Option<u32>,
}

impl <T, C> CallbackWrapper<T, C>
where
    T: Tracked,
    C: StreamingCallback<T>,
{
    /// Create a new filter wrapper.
    /// `preconditions` should be `true` if this filter predicate
    /// is _only_ part of longer patterns (i.e., if some external predicates
    /// fail to match, this filter should no longer be invoked).
    pub fn new(preconditions: bool) -> Self {
        let matches = if preconditions { Some(0) } else { None };
        CallbackWrapper {
            callback: None,
            tracked: std::marker::PhantomData,
            term: matches,
            nonterm: matches,
        }
    }

    /// Returns true if the filter should be invoked.
    pub fn is_active(&self) -> bool {
        self.callback.is_some()
    }

    /// Invoked when a filter pattern for callback has matched.
    pub fn set_active(&mut self) {
        self.callback = Some(C::new());
    }

    /// Invoked when the callback has definitively not matched
    /// or when the callback has unsubscribed.
    pub fn set_inactive(&mut self) {
        self.callback = None;
    }
}
use super::timer::CallbackTimer;
use super::Tracked;
use crate::L4Pdu;

/// This streaming callback trait should be used when a user can
/// accept read-only access to tracked data. If no internal state is
/// needed, the user can implement this trait on an empty struct.
/// If the user needs mutable tracked data, they should store it internally,
/// request updates on each packet, and maintain their own timer for any
/// separate processing.
pub trait StreamingCallback<T>
where
    T: Tracked,
{
    /// Initializes internal data, if applicable.
    /// Called on first packet in connection.
    fn new() -> Self;
    /// Invoked at specified intervals with tracked data
    /// (if a filter pattern matched). Phases of interest must
    /// be specified as attributes, e.g.: #[invoke(L4Payload)]
    /// Interval must be specified as attribute, e.g. #[streaming(packets=1)]
    /// The last PDU seen will also be delivered.
    /// If only PDUs are requested, use TrackedEmpty.
    /// If PDUs are requested, packets will be buffered until ready to be delivered.
    ///
    /// TODO this should be a wrapper so that multiple tracked datatypes can
    /// be passed in.
    fn invoke(&mut self, data: &T, pdu: &L4Pdu) -> bool;
}

#[doc(hidden)]
/// Private structure generated by the compiler for each StreamingCallback.
pub struct TimedCallbackWrapper<T, C, R>
where
    T: Tracked,
    C: StreamingCallback<T>,
    R: CallbackTimer,
{
    /// Starts as `Some`; changed to `None` if:
    /// - Filter itself fails to match, or
    /// - Term + nonterm == 0
    /// When this is None, the filter is no longer active and thus
    /// no longer invoked.
    pub callback: Option<C>,
    /// Owned tracked data. This is initialized at the start of the connection
    /// and accumulated until the callback is ready to be invoked.
    /// After that, it is delivered when the callback timer fires.
    /// After each delivery, it is cleared such that, at the next invocation,
    /// only new data is delivered.
    tracked: Option<T>,
    /// Streaming callback timer. Once active, the timer is updated on every
    timer: Option<R>,
}

impl<T, C, R> TimedCallbackWrapper<T, C, R>
where
    T: Tracked,
    C: StreamingCallback<T>,
    R: CallbackTimer,
{
    /// Create a new callback wrapper.
    pub fn new(first_packet: &L4Pdu) -> Self {
        TimedCallbackWrapper {
            callback: None,
            tracked: Some(T::new(first_packet)),
            timer: None,
        }
    }

    /// Returns true if the filter should be invoked.
    pub fn is_active(&self) -> bool {
        self.callback.is_some()
    }

    /// Invoked when a filter pattern for callback has matched.
    pub fn set_active(&mut self, counter: u64) {
        self.callback = Some(C::new());
        self.timer = Some(R::new(counter));
    }

    /// Invoked when the callback has unsubscribed.
    pub fn set_inactive(&mut self) {
        self.callback = None;
    }

    /// Invoked on each PDU. Updates the tracked datatype and, if the callback is active,
    /// invokes the timer. If the timer indicates, the callback will execute.
    pub fn update(&mut self, pdu: &L4Pdu) {
        if let Some(tracked) = &mut self.tracked {
            tracked.update(pdu);
            if let Some(timer) = &mut self.timer {
                if timer.update(pdu) {
                    let tracked = self.tracked.as_mut().unwrap();
                    self.callback.as_mut().unwrap().invoke(tracked, pdu);
                    tracked.clear();
                }
            }
        }
    }
}

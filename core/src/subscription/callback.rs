use std::time::{Instant, Duration};

use super::Tracked;
use crate::L4Pdu;

/// This streaming callback trait should be used when a user can
/// accept read-only access to tracked data. If no internal state is
/// needed, the user can implement this trait on an empty struct.
/// If the user needs mutable tracked data, they should store it internally,
/// request updates on each packet, and maintain their own timer for any
/// separate processing.
pub trait StreamingCallback<T>
where T: Tracked
{
    /// Initializes internal data, if applicable.
    /// Called on first packet in connection.
    fn new() -> Self;
    /// Invoked at specified intervals with tracked data
    /// (if a filter pattern matched). Phases of interest must
    /// be specified as attributes, e.g.: #[invoke(L4Payload)]
    /// Interval must be specified as attribute, e.g. #[streaming(packets=1)]
    /// The last PDU seen will also be delivered.
    /// If only PDUs are requested, use TrackedEmpty.
    /// If PDUs are requested, packets will be buffered until ready to be delivered.
    ///
    /// TODO this should be a wrapper so that multiple tracked datatypes can
    /// be passed in.
    fn invoke(&mut self, data: &T, pdu: &L4Pdu) -> bool;
}

#[doc(hidden)]
/// Private structure generated by the compiler for each StreamingCallback.
pub struct CallbackWrapper<T, C, R>
where
    T: Tracked,
    C: StreamingCallback<T>,
    R: CallbackTimer,
{
    /// Starts as `Some`; changed to `None` if:
    /// - Filter itself fails to match, or
    /// - Term + nonterm == 0
    /// When this is None, the filter is no longer active and thus
    /// no longer invoked.
    pub callback: Option<C>,
    /// Owned tracked data. This is initialized at the start of the connection
    /// and accumulated until the callback is ready to be invoked.
    /// After that, it is delivered when the callback timer fires.
    /// After each delivery, it is cleared such that, at the next invocation,
    /// only new data is delivered.
    tracked: Option<T>,
    /// Streaming callback timer. Once active, the timer is updated on every
    timer: Option<R>,
}

impl <T, C, R> CallbackWrapper<T, C, R>
where
    T: Tracked,
    C: StreamingCallback<T>,
    R: CallbackTimer
{
    /// Create a new callback wrapper.
    pub fn new(first_packet: &L4Pdu) -> Self {
        CallbackWrapper {
            callback: None,
            tracked: Some(T::new(first_packet)),
            timer: None,
        }
    }

    /// Returns true if the filter should be invoked.
    pub fn is_active(&self) -> bool {
        self.callback.is_some()
    }

    /// Invoked when a filter pattern for callback has matched.
    pub fn set_active(&mut self, counter: u64) {
        self.callback = Some(C::new());
        self.timer = Some(R::new(counter));
    }

    /// Invoked when the callback has unsubscribed.
    pub fn set_inactive(&mut self) {
        self.callback = None;
    }

    /// Invoked on each PDU. Updates the tracked datatype and, if the callback is active,
    /// invokes the timer. If the timer indicates, the callback will execute.
    pub fn update(&mut self, pdu: &L4Pdu) {
        if let Some(tracked) = &mut self.tracked {
            tracked.update(pdu);
            if let Some(timer) = &mut self.timer {
                if timer.update(pdu) {
                    let tracked = self.tracked.as_mut().unwrap();
                    self.callback.as_mut().unwrap().invoke(tracked, pdu);
                    tracked.clear();
                }
            }
        }
    }
}

pub trait CallbackTimer {
    fn new(count: u64) -> Self;
    fn update(&mut self, pdu: &L4Pdu) -> bool;
}

pub struct Milliseconds {
    last_invoked: Instant,
    interval: Duration,
}

impl CallbackTimer for Milliseconds {
    fn new(count: u64) -> Self {
        Self {
            last_invoked: Instant::now(),
            interval: Duration::from_millis(count),
        }
    }

    fn update(&mut self, _pdu: &L4Pdu) -> bool {
        if Instant::now() - self.last_invoked >= self.interval {
            self.last_invoked = Instant::now();
            return true;
        }
        false
    }
}

pub struct Packets {
    count_remaining: u64,
    count: u64,
}

impl CallbackTimer for Packets {
    fn new(count: u64) -> Self {
        Self {
            count_remaining: count,
            count,
        }
    }

    fn update(&mut self, _pdu: &L4Pdu) -> bool {
        self.count_remaining -= 1;
        if self.count_remaining == 0 {
            self.count_remaining = self.count;
            return true;
        }
        false
    }
}

// Bytes, excluding Ethernet, IP, and TCP headers.
pub struct Bytes {
    count_remaining: u64,
    count: u64,
}

impl CallbackTimer for Bytes {
    fn new(count: u64) -> Self {
        Self {
            count_remaining: count,
            count,
        }
    }

    fn update(&mut self, pdu: &L4Pdu) -> bool {
        let len = pdu.length() as u64;
        if len >= self.count_remaining {
            let over = len - self.count_remaining;
            self.count_remaining = if over >= self.count { 0 } else { self.count - over };
            return true;
        }
        self.count_remaining -= len;
        false
    }
}
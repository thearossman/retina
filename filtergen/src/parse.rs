use anyhow::{bail, Result};
use quote::ToTokens;
use retina_core::conntrack::DataLevel;
use retina_core::protocols::stream::IMPLEMENTED_PROTOCOLS;
use serde::{Deserialize, Serialize};
use std::io::BufRead;
use std::str::FromStr;
use syn::{
    parse::{Parse, ParseStream},
    Item, ItemFn, LitStr, TypePath,
};
use thiserror::Error;

/// General representation of a valid return type from a function.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) enum FnReturn {
    Bool,
    FilterResult,
    Constructor(Constructor),
    #[default]
    None,
}

/// Types of constructors (possible return values)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) enum Constructor {
    Sel,
    Opt,
    OptRef,
}

/// General representation of a function (filter, callback, or datatype)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct FnSpec {
    pub(crate) name: String,
    pub(crate) datatypes: Vec<String>,
    pub(crate) returns: FnReturn,
}

/// Spec generated by #[callback] tag on a function.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct CallbackFnSpec {
    pub(crate) filter: String,
    pub(crate) level: Vec<DataLevel>,
    pub(crate) func: FnSpec,
    pub(crate) expl_parsers: Vec<String>,
}

/// Spec generated by #[callback] tag on a struct.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct CallbackGroupSpec {
    pub(crate) filter: String,
    pub(crate) level: Option<DataLevel>,
    pub(crate) name: String,
    pub(crate) expl_parsers: Vec<String>,
}

/// Spec generated by #[callback_group]
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct CallbackGroupFnSpec {
    pub(crate) level: Vec<DataLevel>,
    pub(crate) group_name: String,
    pub(crate) func: FnSpec,
}

/// Spec generated by #[filter] tag on a function
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct FilterFnSpec {
    pub(crate) level: Vec<DataLevel>,
    pub(crate) func: FnSpec,
    pub(crate) expl_parsers: Vec<String>,
}

/// Spec generated by #[filter] tag on a struct
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct FilterGroupSpec {
    pub(crate) level: Option<DataLevel>,
    pub(crate) name: String,
    pub(crate) expl_parsers: Vec<String>,
}

/// Spec generated by #[filter_group]
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct FilterGroupFnSpec {
    pub(crate) level: Vec<DataLevel>,
    pub(crate) group_name: String,
    pub(crate) func: FnSpec,
}

/// Spec generated by #[datatype]
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct DatatypeSpec {
    pub(crate) name: String,
    pub(crate) level: Option<DataLevel>,
    pub(crate) expl_parsers: Vec<String>,
}

/// Spec generated by #[datatype_group]
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct DatatypeFnSpec {
    pub(crate) group_name: String,
    // TODO only allowed datatypes here are StateTxData and L4Pdu
    pub(crate) func: FnSpec,
    pub(crate) level: Vec<DataLevel>,
}

/// Valid inputs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) enum ParsedInput {
    Callback(CallbackFnSpec),
    CallbackGroup(CallbackGroupSpec),
    CallbackGroupFn(CallbackGroupFnSpec),
    Filter(FilterFnSpec),
    FilterGroup(FilterGroupSpec),
    FilterGroupFn(FilterGroupFnSpec),
    Datatype(DatatypeSpec),
    DatatypeFn(DatatypeFnSpec),
}

impl FnSpec {
    pub(crate) fn from_item_fn(func: &ItemFn) -> Self {
        let name = func.sig.ident.to_string();
        let datatypes = func
            .sig
            .inputs
            .iter()
            .filter_map(|arg| {
                if let syn::FnArg::Typed(syn::PatType { pat: _, ty, .. }) = arg {
                    let mut param_type: String = (*ty).to_token_stream().to_string();
                    if !param_type.contains("&") {
                        panic!("{:?}", ParserError::PassByRef(name.clone()));
                    }
                    param_type = param_type.replace("&", "").trim().to_string();
                    return Some(param_type);
                }
                None
            })
            .collect::<Vec<_>>();

        let returns = match &func.sig.output {
            syn::ReturnType::Default => FnReturn::None,
            syn::ReturnType::Type(_, ty) => match ty.as_ref() {
                syn::Type::Path(type_path) => {
                    if type_path.path.is_ident("bool") {
                        FnReturn::Bool
                    } else if type_path.path.is_ident("FilterResult") {
                        FnReturn::FilterResult
                    } else if type_path.path.is_ident("Self") || type_path.path.is_ident(&name) {
                        FnReturn::Constructor(Constructor::Sel)
                    } else if type_path.path.segments.len() == 1
                        && type_path.path.segments[0].ident == "Option"
                    {
                        Self::parse_option(type_path, &name)
                    } else {
                        panic!("{}", ParserError::InvalidReturn(name.clone()));
                    }
                }
                _ => panic!("{}", ParserError::InvalidReturn(name.clone())),
            },
        };

        Self {
            name,
            datatypes,
            returns,
        }
    }

    // Helper - parses Option<Self> or Option<&Self>
    fn parse_option(type_path: &TypePath, name: &String) -> FnReturn {
        if let syn::PathArguments::AngleBracketed(args) = &type_path.path.segments[0].arguments {
            if let Some(syn::GenericArgument::Type(arg)) = args.args.first() {
                match arg {
                    syn::Type::Path(type_path) => {
                        if type_path.path.is_ident("Self") || type_path.path.is_ident(&name) {
                            return FnReturn::Constructor(Constructor::Opt);
                        }
                    }
                    syn::Type::Reference(type_ref) => {
                        if let syn::Type::Path(type_path) = type_ref.elem.as_ref() {
                            if type_path.path.is_ident("Self") || type_path.path.is_ident(&name) {
                                return FnReturn::Constructor(Constructor::OptRef);
                            }
                        }
                    }
                    _ => panic!("{}", ParserError::InvalidReturn(name.clone())),
                }
            }
        }
        panic!("{}", ParserError::InvalidReturn(name.clone()));
    }
}

impl ParsedInput {
    pub(crate) fn parse(&mut self, input: &Item, args: Option<String>) -> Result<()> {
        match &input {
            syn::Item::Fn(itemfn) => {
                let spec = FnSpec::from_item_fn(&itemfn);
                match self {
                    // Expecting: callback func annotated with #[callback] macro
                    // Requires filter. Can specify levels.
                    // Streaming CBs return bool (TODO loosen this requirement in future)
                    Self::Callback(func) => {
                        let (mut fil, level, expl_parsers) = InputKeys::callback(args, &spec.name)?;
                        if !matches!(spec.returns, FnReturn::Bool | FnReturn::None) {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        if !matches!(spec.returns, FnReturn::Bool)
                            && level.iter().any(|l| l.is_streaming())
                        {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        if fil.contains("file=") {
                            fil = InputKeys::parse_filters_from_file(&fil)?;
                        }
                        func.filter = fil;
                        func.level = level;
                        func.func = spec;
                        func.expl_parsers = expl_parsers;
                    }
                    // Expecting: callback group func annotated with #[callback_group] macro
                    // Requires named callback group and (optional) levels.
                    // Must return bool (TODO loosen this requirement in future)
                    Self::CallbackGroupFn(func) => {
                        if !matches!(spec.returns, FnReturn::Bool) {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        let (group_name, level) = InputKeys::grouped_fn(args, &spec.name)?;
                        func.group_name = group_name;
                        func.level = level;
                        func.func = spec;
                    }
                    // Expecting: custom filter func. Optional filter levels.
                    Self::Filter(func) => {
                        if !matches!(spec.returns, FnReturn::FilterResult) {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        if let Some(args) = args {
                            let keys = InputKeys::from_string(args)?;
                            func.level = keys.levels;
                            func.expl_parsers = keys.parsers;
                            if let Some(key) = keys.first {
                                bail!(ParserError::InvalidParam(key, spec.name.clone()));
                            }
                        }
                        func.func = spec;
                    }
                    // Expecting: group name and (optional) levels
                    Self::FilterGroupFn(func) => {
                        if !matches!(spec.returns, FnReturn::FilterResult) {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        let (group_name, level) = InputKeys::grouped_fn(args, &spec.name)?;
                        func.group_name = group_name;
                        func.level = level;
                        func.func = spec;
                    }
                    // Expecting: group name and (required) levels
                    Self::DatatypeFn(func) => {
                        if !matches!(spec.returns, FnReturn::None | FnReturn::Constructor(_)) {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        let (group_name, level) = InputKeys::grouped_fn(args, &spec.name)?;
                        if level.is_empty() {
                            bail!(ParserError::MissingLevel(format!(
                                "{}:{}",
                                group_name, spec.name
                            )));
                        }
                        func.group_name = group_name;
                        if level.len() < 1 {
                            bail!(ParserError::MissingParam("level".into(), spec.name.clone()));
                        }
                        func.level = level;
                        func.func = spec;
                        // Extra rules for datatypes - TODO maybe relax these?
                        assert!(
                            func.level.iter().all(|l| l.is_streaming())
                                || func.level.iter().all(|l| !l.is_streaming()),
                            "{}:{} mixed streaming and non-streaming states",
                            func.group_name,
                            func.func.name
                        );
                        assert!(
                            func.func.datatypes.len() == 1,
                            "{}:{} requested multiple datatypes",
                            func.group_name,
                            func.func.name
                        );
                        assert!(
                            // TODO group these "allowed inputs" together
                            func.func.datatypes[0].contains("L4Pdu")
                                || func.func.datatypes[0].contains("StateTxData")
                                || func.func.datatypes[0].contains("Session")
                                || func.func.datatypes[0].contains("Mbuf"),
                            "{}:{} requested non-trivial datatypes",
                            func.group_name,
                            func.func.name
                        );
                    }
                    Self::Datatype(dt) => {
                        if !matches!(spec.returns, FnReturn::Constructor(_)) {
                            bail!(ParserError::InvalidReturn(spec.name));
                        }
                        match args {
                            Some(args) => {
                                let mut keys = InputKeys::from_string(args)?;
                                match keys.first {
                                    Some(name) => dt.name = name,
                                    None => bail!(ParserError::MissingParam(
                                        "name".into(),
                                        spec.name.clone()
                                    )),
                                }
                                dt.level = match keys.levels.len() {
                                    0 => None,
                                    1 => Some(keys.levels.pop().unwrap()),
                                    _ => bail!(ParserError::InvalidParam(
                                        "[levels > 1]".into(),
                                        spec.name.clone()
                                    )),
                                };
                            }
                            None => {
                                bail!(ParserError::MissingParam("name".into(), spec.name.clone()))
                            }
                        }
                    }
                    _ => bail!(ParserError::InvalidMacro(spec.name)),
                }
            }
            syn::Item::Struct(st) => {
                let name = st.ident.to_string();
                match self {
                    Self::Callback(_) => {
                        let (mut filter, mut level, expl_parsers) =
                            InputKeys::callback(args, &name)?;
                        let level = match level.len() {
                            0 => None,
                            1 => Some(level.pop().unwrap()),
                            _ => bail!(ParserError::InvalidParam(
                                "[levels > 1]".into(),
                                name.clone()
                            )),
                        };
                        if filter.contains("file=") {
                            filter = InputKeys::parse_filters_from_file(&filter)?;
                        }
                        *self = ParsedInput::CallbackGroup(CallbackGroupSpec {
                            filter,
                            level,
                            name,
                            expl_parsers,
                        });
                    }
                    Self::CallbackGroup(cb) => {
                        let (mut filter, mut level, expl_parsers) =
                            InputKeys::callback(args, &name)?;
                        cb.level = match level.len() {
                            0 => None,
                            1 => Some(level.pop().unwrap()),
                            _ => bail!(ParserError::InvalidParam(
                                "[levels > 1]".into(),
                                name.clone()
                            )),
                        };
                        if filter.contains("file=") {
                            filter = InputKeys::parse_filters_from_file(&filter)?;
                        }
                        cb.filter = filter;
                        cb.name = name;
                        cb.expl_parsers = expl_parsers;
                    }
                    Self::Filter(_) => {
                        let struct_def = InputKeys::struct_def(args, &name)?;
                        *self = ParsedInput::FilterGroup(FilterGroupSpec {
                            level: struct_def.0,
                            name: name,
                            expl_parsers: struct_def.1,
                        });
                    }
                    Self::FilterGroup(fil) => {
                        let struct_def = InputKeys::struct_def(args, &name)?;
                        fil.level = struct_def.0;
                        fil.name = name;
                        fil.expl_parsers = struct_def.1;
                    }
                    Self::Datatype(dt) => {
                        let struct_def = InputKeys::struct_def(args, &name)?;
                        dt.level = struct_def.0;
                        dt.name = name;
                        dt.expl_parsers = struct_def.1;
                    }
                    _ => bail!(ParserError::InvalidMacro(name)),
                }
            }
            syn::Item::Type(ty) => {
                let name = ty.ident.to_string();
                match self {
                    Self::Datatype(dt) => {
                        let struct_def = InputKeys::struct_def(args, &name)?;
                        dt.level = struct_def.0;
                        dt.name = name;
                        dt.expl_parsers = struct_def.1;
                    }
                    _ => bail!(ParserError::InvalidMacro(name)),
                }
            }
            _ => {
                panic!("{}", ParserError::InvalidType(format!("{:?}", input)));
            }
        }
        Ok(())
    }

    /// Accessors ///
    pub(crate) fn name(&self) -> &String {
        match self {
            Self::Callback(i) => &i.func.name,
            Self::CallbackGroup(i) => &i.name,
            Self::CallbackGroupFn(i) => &i.func.name,
            Self::Filter(i) => &i.func.name,
            Self::FilterGroup(i) => &i.name,
            Self::FilterGroupFn(i) => &i.func.name,
            Self::Datatype(i) => &i.name,
            Self::DatatypeFn(i) => &i.func.name,
        }
    }

    pub(crate) fn levels(&self) -> Vec<DataLevel> {
        match self {
            Self::Callback(i) => i.level.clone(),
            Self::CallbackGroup(i) => match i.level {
                Some(l) => vec![l],
                None => vec![],
            },
            Self::CallbackGroupFn(i) => i.level.clone(),
            Self::Filter(i) => i.level.clone(),
            Self::FilterGroup(i) => match i.level {
                Some(l) => vec![l],
                None => vec![],
            },
            Self::FilterGroupFn(i) => i.level.clone(),
            Self::Datatype(i) => match i.level {
                Some(l) => vec![l],
                None => vec![],
            },
            Self::DatatypeFn(i) => i.level.clone(),
        }
    }

    /// No associated function to call here
    pub(crate) fn is_group(&self) -> bool {
        matches!(
            self,
            ParsedInput::CallbackGroup(_) | ParsedInput::FilterGroup(_)
        )
    }

    pub(crate) fn expl_parsers(&self) -> Vec<String> {
        match self {
            Self::Callback(i) => i.expl_parsers.clone(),
            Self::CallbackGroup(i) => i.expl_parsers.clone(),
            Self::CallbackGroupFn(_) => vec![],
            Self::Filter(i) => i.expl_parsers.clone(),
            Self::FilterGroup(i) => i.expl_parsers.clone(),
            Self::FilterGroupFn(_) => vec![],
            Self::Datatype(i) => i.expl_parsers.clone(),
            Self::DatatypeFn(_) => vec![],
        }
    }

    /// Get group name, if applicable
    pub(crate) fn group(&self) -> Option<String> {
        match self {
            Self::Callback(_) => None,
            Self::CallbackGroup(i) => Some(i.name.clone()),
            Self::CallbackGroupFn(i) => Some(i.group_name.clone()),
            Self::Filter(_) => None,
            Self::FilterGroup(i) => Some(i.name.clone()),
            Self::FilterGroupFn(i) => Some(i.group_name.clone()),
            Self::Datatype(i) => Some(i.name.clone()),
            Self::DatatypeFn(i) => Some(i.group_name.clone()),
        }
    }
}

#[derive(Default, Clone)]
pub(crate) struct InputKeys {
    first: Option<String>,
    levels: Vec<DataLevel>,
    parsers: Vec<String>,
}

impl InputKeys {
    fn from_string(inp: String) -> Result<Self> {
        let parsed: Vec<(String, String)> = inp
            .split(',')
            .enumerate()
            .map(|(i, pair)| {
                let pair = pair.trim();
                // Allow first value to not have an associated key
                // Note that `file=` can be used in filters
                if i == 0 && (!pair.contains('=') || pair.contains("file=")) {
                    ("".to_string(), pair.to_string())
                } else {
                    let mut parts = pair.splitn(2, '=');
                    match (parts.next(), parts.next()) {
                        (Some(k), Some(v)) => (k.trim().to_string(), v.trim().to_string()),
                        _ => panic!("{}", ParserError::MalformedKeys(inp.clone())),
                    }
                }
            })
            .collect();
        let mut ret = Self::default();
        let mut reassembled = false;
        for (k, v) in parsed {
            let k = k.to_lowercase();
            if k.is_empty() {
                assert!(ret.first.is_none(), "Multiple values without keys: {}", inp);
                ret.first = Some(v);
            } else if k.contains("filter") {
                assert!(
                    ret.first.is_none(),
                    "Expect filter to be first or labeled: {}",
                    inp
                );
                ret.first = Some(v);
            } else if k.contains("group") {
                assert!(
                    ret.first.is_none(),
                    "Expect group to be first or labeled: {}",
                    inp
                );
                ret.first = Some(v);
            } else if k.contains("level") {
                for l in v.split("|") {
                    ret.levels
                        .push(DataLevel::from_str(l.trim()).expect("`level` key without values"));
                }
            } else if k.contains("reassembled") {
                reassembled =
                    bool::from_str(&v).expect(&format!("{}", ParserError::InvalidValue(k, v)));
            } else if k.contains("name") {
                assert!(
                    ret.first.is_none(),
                    "Expect name to be first or labeled: {}",
                    inp
                );
                ret.first = Some(v);
            } else if k.contains("parsers") {
                assert!(
                    IMPLEMENTED_PROTOCOLS.contains(&v.as_str()),
                    "{} parsing is not supported",
                    v
                );
                ret.parsers.push(v);
            } else {
                bail!(ParserError::InvalidKey(k));
            }
        }
        ret.levels.sort();
        ret.levels.dedup();
        // L7InPayload currently broken
        assert!(
            !ret.levels.contains(&DataLevel::L7InPayload(false)),
            "L7InPayload not yet supported"
        );
        if reassembled {
            for l in &mut ret.levels {
                if matches!(l, DataLevel::L4InPayload(false)) {
                    *l = DataLevel::L4InPayload(true);
                }
                if matches!(l, DataLevel::L7InPayload(false)) {
                    *l = DataLevel::L7InPayload(true);
                }
            }
        }

        Ok(ret)
    }

    fn parse_filters_from_file(filter: &String) -> Result<String> {
        assert!(filter.contains("file="), "No file= in {}", filter);
        let re = regex::Regex::new(r"file=([^\s]+)").unwrap();
        let env_re = regex::Regex::new(r"\$([A-Za-z0-9_]+)").unwrap();
        let expanded = re
            .replace_all(&filter, |results: &regex::Captures| {
                let mut filters = vec![];
                // Raw file path
                let fp = &results[1];
                // Expand env variables
                let fp = env_re
                    .replace_all(fp, |env_results: &regex::Captures| {
                        std::env::var(&env_results[1])
                            .expect(&format!("Failed to find env variable {}", &env_results[1]))
                    })
                    .to_string();
                let file =
                    std::fs::File::open(fp.clone()).expect(&format!("Failed to open file: {}", fp));
                let reader = std::io::BufReader::new(file);
                for (idx, line) in reader.lines().enumerate() {
                    let line = line
                        .map_err(|_| {
                            ParserError::InvalidValue(
                                format!("fp {}, line {}", fp, idx),
                                fp.clone(),
                            )
                        })
                        .unwrap();
                    if !line.trim().is_empty() && !line.starts_with('#') {
                        filters.push(line);
                    }
                }
                String::from("(") + &filters.join(" or ") + ")"
            })
            .to_string();
        println!("Parsed filter to: {}", expanded);
        Ok(expanded)
    }

    fn grouped_fn(args: Option<String>, name: &String) -> Result<(String, Vec<DataLevel>)> {
        let mut ret = (String::new(), Vec::new());
        match args {
            Some(args) => {
                let keys = InputKeys::from_string(args)?;
                match keys.first {
                    Some(group) => ret.0 = group,
                    None => bail!(ParserError::MissingParam("group".into(), name.clone())),
                }
                ret.1 = keys.levels;
                assert!(
                    keys.parsers.is_empty(),
                    "Parsers should be specified in group def, not functions: {}",
                    name
                );
            }
            None => bail!(ParserError::MissingParam("group".into(), name.clone())),
        }
        Ok(ret)
    }

    fn callback(
        args: Option<String>,
        name: &String,
    ) -> Result<(String, Vec<DataLevel>, Vec<String>)> {
        let mut ret = (String::new(), Vec::new(), Vec::new());
        match args {
            Some(args) => {
                let keys = InputKeys::from_string(args)?;
                match keys.first {
                    Some(fil) => ret.0 = fil,
                    None => bail!(ParserError::MissingParam("filter".into(), name.clone())),
                }
                ret.1 = keys.levels;
                ret.2 = keys.parsers;
            }
            None => bail!(ParserError::MissingParam("filter".into(), name.clone())),
        }
        Ok(ret)
    }

    fn struct_def(args: Option<String>, name: &String) -> Result<(Option<DataLevel>, Vec<String>)> {
        let mut ret = (None, Vec::new());
        if let Some(args) = args {
            let mut keys = InputKeys::from_string(args)?;
            if let Some(l) = keys.first {
                let level = match DataLevel::from_str(&l) {
                    Ok(level) => level,
                    Err(_) => bail!(ParserError::InvalidParam(l.clone(), name.clone())),
                };
                keys.levels.push(level);
            }
            ret.0 = match keys.levels.len() {
                0 => None,
                1 => Some(keys.levels.pop().unwrap()),
                _ => bail!(ParserError::InvalidParam(
                    "[levels > 1]".into(),
                    name.clone()
                )),
            };
            ret.1 = keys.parsers;
        }
        Ok(ret)
    }
}

/// UTIL: So that we can parse an input TokenStream as an Option<String>
/// in lib.rs (see parse_macro_input!(args as StringOpt))
pub(crate) struct StringOpt {
    pub(crate) value: Option<String>,
}
impl Parse for StringOpt {
    fn parse(input: ParseStream) -> syn::parse::Result<Self> {
        if input.is_empty() {
            return Ok(StringOpt { value: None });
        }
        if input.peek(LitStr) {
            let s: LitStr = input.parse()?;
            Ok(StringOpt {
                value: Some(s.value()),
            })
        } else {
            Err(syn::Error::new(input.span(), "Expected LitStr in input"))
        }
    }
}

/// Valid errors when parsing
#[derive(Error, Debug)]
pub enum ParserError {
    #[error("Invalid return value for {0}")]
    InvalidReturn(String),
    #[error("Incompatible macro for {0}")]
    InvalidMacro(String),
    #[error("Arguments to {0} are not passed by reference")]
    PassByRef(String),
    #[error("Input not in key=value format: {0}")]
    MalformedKeys(String),
    #[error("Invalid key: {0}")]
    InvalidKey(String),
    #[error("Invalid value for key: {0}, {1}")]
    InvalidValue(String, String),
    #[error("Must specify macro input \'{0}\' for {1}")]
    MissingParam(String, String),
    #[error("Invalid macro input {0} for {1}")]
    InvalidParam(String, String),
    #[error("Invalid input datatype for macro {0}")]
    InvalidType(String),
    #[error("{0} requires explicit level annotation")]
    MissingLevel(String),
}
